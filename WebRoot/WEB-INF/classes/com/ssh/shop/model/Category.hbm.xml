<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
<!-- 
    Mapping file autogenerated by MyEclipse Persistence Tools
-->
<hibernate-mapping>
    <class name="com.ssh.shop.model.Category" table="category" catalog="shop">
        <id name="id" type="java.lang.Integer">
            <column name="id" />
            <generator class="native" />
        </id>
        <property name="type" type="java.lang.String">
            <column name="type" length="20" />
        </property>
        <property name="hot" type="java.lang.Boolean">
            <column name="hot" />
        </property>
        
        
        <!-- 
        	多个类别可以对应一个管理员 : lazy="false",级联查询关联对象
        	N+1问题：执行一条select语句查询当前表，执行N条语句查询与当前表关联的表，N是不同的关联数。效率很差
        		lazy：是否及时加载，false是及时加载
        		fetch：以什么样的方式加载，select（默认）：select语句查询；join：以join语句查询
        		注意：join在many-to-one中是无效的，在one-to-many中有效。
        			A表===>关联===>B表===C表...
        		所以，在任何情况下，都不要在xml中配置lazy="false" fetch="join"
        	N+1解决方案：
        		自己写hql语句，如加入 hql = "from Category c left join fetch c.account where type = :type",
        			left join代表左外连接，fetch代表把查出来的c.account抓取到Category对象中。sql语句如下：
        			select  c.* , a.*
						from 
					shop.category c left outer join shop.account a 
						on category0_.aid=a.id 
						where c.type like ?
			如果不写hql，默认为懒加载lazy="true"，抛异常：
				org.hibernate.LazyInitializationException: could not initialize proxy - no Session
				因为session在加载Category后关闭，再去加载对应的关联的时候，session已经关闭了。
        -->
        <many-to-one name="account" class="com.ssh.shop.model.Account" lazy="false" >
        	<column name="aid"/> <!-- 外键 -->
        </many-to-one>
    </class>
</hibernate-mapping>
